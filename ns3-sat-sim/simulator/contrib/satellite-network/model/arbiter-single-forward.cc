/*
 * Copyright (c) 2020 ETH Zurich
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Simon               2020
 */

#include "arbiter-single-forward.h"
#include "orbit-aware-threat-model.h"
#include "ns3/simulator.h"
#include "ns3/random-variable-stream.h"
#include "ns3/log.h"

NS_LOG_COMPONENT_DEFINE ("ArbiterSingleForward");

namespace ns3 {

NS_OBJECT_ENSURE_REGISTERED (ArbiterSingleForward);

TypeId
ArbiterSingleForward::GetTypeId (void)
{
    static TypeId tid = TypeId ("ns3::ArbiterSingleForward")
            .SetParent<ArbiterSatnet> ()
            .SetGroupName("BasicSim")
    ;
    return tid;
}

ArbiterSingleForward::ArbiterSingleForward(
        Ptr<Node> this_node,
        NodeContainer nodes,
        std::vector<std::tuple<int32_t, int32_t, int32_t>> next_hop_list
) : ArbiterSatnet(this_node, nodes)
{
    m_next_hop_list = next_hop_list;
}

std::tuple<int32_t, int32_t, int32_t>
ArbiterSingleForward::TopologySatelliteNetworkDecide(
        int32_t source_node_id,
        int32_t target_node_id,
        Ptr<const Packet> pkt,
        Ipv4Header const &ipHeader,
        bool is_socket_request_for_source_ip)
{
    // Default: follow static next-hop list generated by satgenpy.
    std::tuple<int32_t, int32_t, int32_t> decision =
        m_next_hop_list[target_node_id];

    // For source-IP lookup requests we do not want to drop, since those
    // packets are not actually forwarded.
    if (!is_socket_request_for_source_ip && g_orbitAwareThreatModel != 0)
    {
        double dropProb = 0.0;
        if (g_orbitAwareThreatModel->IsNodeBlackhole (m_node_id,
                                                      Simulator::Now (),
                                                      dropProb))
        {
            if (dropProb >= 1.0)
            {
                NS_LOG_DEBUG ("FULL drop at node "
                              << m_node_id << " (blackhole), t="
                              << Simulator::Now ().GetSeconds ()
                              << ", src_node_id=" << source_node_id
                              << ", target_node_id=" << target_node_id);
                // ArbiterSatnet::Decide interprets next_node_id == -1 as drop.
                return std::make_tuple (-1, -1, -1);
            }
            else if (dropProb > 0.0)
            {
                static Ptr<UniformRandomVariable> uv = 0;
                if (uv == 0)
                {
                    uv = CreateObject<UniformRandomVariable> ();
                }
                double r = uv->GetValue (0.0, 1.0);
                if (r < dropProb)
                {
                    NS_LOG_DEBUG ("GRAYHOLE drop at node "
                                  << m_node_id << " (p=" << dropProb
                                  << ", r=" << r
                                  << "), t=" << Simulator::Now ().GetSeconds ()
                                  << ", src_node_id=" << source_node_id
                                  << ", target_node_id=" << target_node_id);
                    return std::make_tuple (-1, -1, -1);
                }
            }
        }
    }

    // No attack or packet not dropped: use normal forwarding decision.
    return decision;
}

void
ArbiterSingleForward::SetSingleForwardState(int32_t target_node_id,
                                            int32_t next_node_id,
                                            int32_t own_if_id,
                                            int32_t next_if_id)
{
    NS_ABORT_MSG_IF(next_node_id == -2 || own_if_id == -2 || next_if_id == -2,
                    "Not permitted to set invalid (-2).");
    m_next_hop_list[target_node_id] = std::make_tuple(next_node_id, own_if_id, next_if_id);
}

std::string
ArbiterSingleForward::StringReprOfForwardingState()
{
    std::ostringstream res;
    res << "Single-forward state of node " << m_node_id << std::endl;
    for (size_t i = 0; i < m_nodes.GetN(); i++) {
        res << "  -> " << i << ": (" << std::get<0>(m_next_hop_list[i]) << ", "
            << std::get<1>(m_next_hop_list[i]) << ", "
            << std::get<2>(m_next_hop_list[i]) << ")" << std::endl;
    }
    return res.str();
}

} // namespace ns3
